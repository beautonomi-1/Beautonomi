/**
 * scan-routes.mjs
 *
 * Scans the Beautonomi monorepo and produces per-app route inventories
 * as markdown tables under docs/audit/.
 *
 * Usage:  node tooling/audit/scan-routes.mjs
 *
 * No external dependencies — uses only built-in fs and path modules.
 */

import { readdirSync, statSync, writeFileSync, mkdirSync } from "fs";
import { join, relative, sep, posix } from "path";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect every file under `dir` that matches `predicate`. */
function walk(dir, predicate, results = []) {
  let entries;
  try {
    entries = readdirSync(dir);
  } catch {
    return results;
  }
  for (const entry of entries) {
    const full = join(dir, entry);
    let stat;
    try {
      stat = statSync(full);
    } catch {
      continue;
    }
    if (stat.isDirectory()) {
      walk(full, predicate, results);
    } else if (predicate(entry)) {
      results.push(full);
    }
  }
  return results;
}

/** Normalise a Windows path to forward-slash POSIX style. */
function toPosix(p) {
  return p.split(sep).join(posix.sep);
}

// ---------------------------------------------------------------------------
// Next.js  App Router  (apps/web/src/app)
// ---------------------------------------------------------------------------

const NEXTJS_ROUTE_FILES = new Set([
  "page.tsx",
  "page.ts",
  "page.jsx",
  "page.js",
  "route.ts",
  "route.js",
  "layout.tsx",
  "layout.ts",
  "layout.jsx",
  "layout.js",
  "error.tsx",
  "error.ts",
  "error.jsx",
  "error.js",
  "loading.tsx",
  "loading.ts",
  "loading.jsx",
  "loading.js",
  "not-found.tsx",
  "not-found.ts",
  "not-found.jsx",
  "not-found.js",
  "template.tsx",
  "template.ts",
]);

function classifyNextFile(filename) {
  if (filename.startsWith("page.")) return "page";
  if (filename.startsWith("route.")) return "api";
  if (filename.startsWith("layout.")) return "layout";
  if (filename.startsWith("error.")) return "error";
  if (filename.startsWith("loading.")) return "loading";
  if (filename.startsWith("not-found.")) return "not-found";
  if (filename.startsWith("template.")) return "template";
  return "other";
}

function inferNextRoutePath(relFile) {
  // relFile looks like "provider/dashboard/page.tsx" or "api/me/bookings/route.ts"
  const parts = relFile.split(posix.sep);
  parts.pop(); // remove filename
  const routePath = "/" + parts.join("/");
  return routePath === "/" ? "/" : routePath;
}

function scanNextApp(appRoot) {
  const files = walk(appRoot, (name) => NEXTJS_ROUTE_FILES.has(name));
  const rows = files.map((abs) => {
    const rel = toPosix(relative(appRoot, abs));
    const filename = rel.split(posix.sep).pop();
    const type = classifyNextFile(filename);
    const route = inferNextRoutePath(rel);
    return { route, file: rel, type };
  });
  rows.sort((a, b) => a.route.localeCompare(b.route) || a.type.localeCompare(b.type));
  return rows;
}

// ---------------------------------------------------------------------------
// Expo Router  (apps/customer/app  &  apps/provider/app)
// ---------------------------------------------------------------------------

function classifyExpoFile(filename) {
  if (filename === "_layout.tsx" || filename === "_layout.ts") return "layout";
  if (filename === "index.tsx" || filename === "index.ts") return "page";
  return "page";
}

function inferExpoRoutePath(relFile) {
  // relFile looks like "(app)/(tabs)/home.tsx" or "(auth)/_layout.tsx"
  let route = relFile.replace(/\.[^.]+$/, ""); // strip extension
  // _layout files: the route is the directory itself
  if (route.endsWith("/_layout")) {
    route = route.replace(/\/_layout$/, "");
  }
  // index files: the route is the directory itself
  if (route.endsWith("/index")) {
    route = route.replace(/\/index$/, "");
  }
  return "/" + route;
}

function scanExpoApp(appRoot) {
  const files = walk(appRoot, (name) => /\.tsx?$/.test(name));
  const rows = files.map((abs) => {
    const rel = toPosix(relative(appRoot, abs));
    const filename = rel.split(posix.sep).pop();
    const type = classifyExpoFile(filename);
    const route = inferExpoRoutePath(rel);
    return { route, file: rel, type };
  });
  rows.sort((a, b) => a.route.localeCompare(b.route) || a.type.localeCompare(b.type));
  return rows;
}

// ---------------------------------------------------------------------------
// Markdown generation
// ---------------------------------------------------------------------------

function toMarkdownTable(appName, rows) {
  const now = new Date().toISOString().slice(0, 10);
  const lines = [
    `# ${appName} — Route Inventory`,
    "",
    `> Auto-generated by \`tooling/audit/scan-routes.mjs\` on ${now}`,
    "",
    `**Total entries:** ${rows.length}`,
    "",
    "| Route Path | File Path | Type |",
    "| --- | --- | --- |",
  ];
  for (const r of rows) {
    lines.push(`| \`${r.route}\` | \`${r.file}\` | ${r.type} |`);
  }
  lines.push("");
  return lines.join("\n");
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

const REPO_ROOT = join(import.meta.dirname || process.cwd(), "..", "..");
const OUT_DIR = join(REPO_ROOT, "docs", "audit");

// Ensure output dir exists
mkdirSync(OUT_DIR, { recursive: true });

// 1. Web (Next.js App Router)
const webAppRoot = join(REPO_ROOT, "apps", "web", "src", "app");
const webRows = scanNextApp(webAppRoot);
const webMd = toMarkdownTable("Web (Next.js App Router)", webRows);
writeFileSync(join(OUT_DIR, "ROUTES_WEB.md"), webMd, "utf-8");
console.log(`✔  ROUTES_WEB.md — ${webRows.length} entries`);

// 2. Customer (Expo Router)
const customerAppRoot = join(REPO_ROOT, "apps", "customer", "app");
const customerRows = scanExpoApp(customerAppRoot);
const customerMd = toMarkdownTable("Customer App (Expo Router)", customerRows);
writeFileSync(join(OUT_DIR, "ROUTES_CUSTOMER.md"), customerMd, "utf-8");
console.log(`✔  ROUTES_CUSTOMER.md — ${customerRows.length} entries`);

// 3. Provider (Expo Router)
const providerAppRoot = join(REPO_ROOT, "apps", "provider", "app");
const providerRows = scanExpoApp(providerAppRoot);
const providerMd = toMarkdownTable("Provider App (Expo Router)", providerRows);
writeFileSync(join(OUT_DIR, "ROUTES_PROVIDER.md"), providerMd, "utf-8");
console.log(`✔  ROUTES_PROVIDER.md — ${providerRows.length} entries`);

console.log(`\nDone. Files written to ${toPosix(relative(REPO_ROOT, OUT_DIR))}/`);
